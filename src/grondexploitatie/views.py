import re
import datetime
import logging
import json
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.reverse import reverse
from django.http import JsonResponse
from django.db import connection

from rest_framework.status import HTTP_400_BAD_REQUEST, HTTP_404_NOT_FOUND

log = logging.getLogger(__name__)


def get_start_jaar(request):
    now = datetime.datetime.now()
    current_year = now.year
    if 'start_jaar' in request.query_params:
        start_jaar = request.query_params['start_jaar']
        start_jaar = int(start_jaar)
        if not 1900 <= start_jaar <= current_year + 5:
            raise ValueError
    else:
        start_jaar = current_year
    return start_jaar


class ProjectList(APIView):
    def get(self, request, format=None):
        """
        Geef lijst van alle projecten waarvoor er baten zijn vanaf het 'start_jaar'
        Default is 'start_jaar' het huidige jaar
        """
        try:
            start_jaar = get_start_jaar(request)
        except ValueError:
            return Response(status=HTTP_400_BAD_REQUEST)

        sql = '''select g.plannr as project
        , g.plannaam as naam
        from grex_grenzen_ogagis_2016 g
        join planex p on g.plannr = p.plannr
        where p.kosten_baten = 'Baten'
        and p.periode >= %s
        group by 1,2 order by 1,2
        '''
        results = []
        with connection.cursor() as cursor:
            cursor.execute(sql, [start_jaar])
            for row in cursor.fetchall():
                (plannr, plannaam) = row
                href = reverse('project_detail', kwargs=dict(plannr=plannr), request=request)
                results.append({
                    'plannr': plannr,
                    'plannaam': plannaam,
                    '_links': {
                        'self': {
                            'href': href
                        }
                    }
                })

        data = {
            "count": len(results),
            "results": results,
        }

        return JsonResponse(data)


class ProjectDetail(APIView):
    """
    Toon details voor project met baten begroot per categorie vanaf 'start_jaar'
    Default is 'start_jaar' het huidige jaar

    Indien parameter 'use_period_groups' is meegegeven dan worden de bate niet
    alleen per categorie, maar ook per periode van vier jaar en het huidige jaar
    weergegeven
    """

    def get(self, request, plannr): # noqa C901
        if not re.match('^\d{5}$', plannr):
            # This should never occur, see url spec in urls.py
            return Response(status=HTTP_400_BAD_REQUEST)

        try:
            start_jaar = get_start_jaar(request)
        except ValueError:
            return Response(status=HTTP_400_BAD_REQUEST)

        if 'use_period_groups' in request.query_params and request.query_params['use_period_groups'].lower() != 'false':
            use_period_groups = True
        else:
            use_period_groups = False

        sql = '''select g.plannr as project
                , g.plannaam as naam
                , g.startdatum as startdatum
                , g.planstatus as status
                , ST_AsGeoJSON(g.wkb_geometry) as geometrie
                , p.begroting_naam as begroting
                , p.prijspeildatum as prijspeildatum
                , m.rapportagepost as categorie
                , p.periode as periode
                , p.fase as fase
                , sum(p.nw_begroot) as begroot
        from grex_grenzen_ogagis_2016 g
        left join planex p on g.plannr = p.plannr
        left join mapping_rapportage m on m.cataloguspost = cast(p.cataloguspost_nummer as double precision)
        where (p is NULL or p.kosten_baten = 'Baten')
            and (p is NULL or p.periode >= %s)
            and g.plannr = %s
        group by  g.plannr
                , g,plannaam
                , g.startdatum
                , g.planstatus
                , g.wkb_geometry
                , p.begroting_naam
                , p.prijspeildatum
                , m.rapportagepost
                , p.periode
                , p.fase
        order by 1, 2
        '''

        data = {}
        period_bucket_size = 4
        with connection.cursor() as cursor:
            cursor.execute(sql, [start_jaar, plannr])
            for row in cursor.fetchall():
                (plannr, plannaam, startdatum, planstatus, geometrie, begroting,
                 prijspeildatum, categorie, periode, fase, begroot) = row
                periode = int(periode) if periode else None
                geometrie = json.loads(geometrie)
                data['_display'] = plannaam
                if 'plannr' not in data:
                    data.update({
                        'plannr': plannr,
                        'plannaam': plannaam,
                        'startdatum': startdatum,
                        'planstatus': planstatus,
                        'geometrie': geometrie,
                        'begroting': begroting,
                        'prijspeildatum': prijspeildatum,
                        'fase': fase,
                    })
                elif not (plannr == data['plannr'] and
                          plannaam == data['plannaam'] and
                          startdatum == data['startdatum'] and
                          planstatus == data['planstatus'] and
                          begroting == data['begroting'] and
                          prijspeildatum == data['prijspeildatum'] and
                          fase == data['fase']):
                    log.error("Wrong values in row {}".format(row))
                if periode is None:
                    data['begroot'] = None
                    pass
                else:
                    if use_period_groups:
                        # We will group in buckets of the current year and then in periods of four years
                        if periode == start_jaar:
                            bucket_name = str(periode)+ '-' + str(periode)
                        else:
                            bucket = int((periode - (start_jaar + 1)) / period_bucket_size)
                            start_bucket_jaar = (start_jaar + 1) + period_bucket_size * bucket
                            end_bucket_jaar = start_bucket_jaar + period_bucket_size - 1
                            bucket_name = str(start_bucket_jaar) + '-' + str(end_bucket_jaar)
                        if 'begroot' not in data:
                            data['begroot'] = dict()
                        if categorie not in data['begroot']:
                            data['begroot'][categorie] = dict()
                        if bucket_name not in data['begroot'][categorie]:
                            data['begroot'][categorie][bucket_name] = 0
                        data['begroot'][categorie][bucket_name] += begroot
                    else:
                        if 'begroot' not in data:
                            data['begroot'] = dict()
                        if categorie not in data['begroot']:
                            data['begroot'][categorie] = [
                                {
                                    "start": str(start_jaar),
                                    "end": str(periode),
                                    "begroot": 0
                                }
                            ]
                        data['begroot'][categorie][0]["begroot"] += begroot

        if len(data) == 0:
            return Response(status=HTTP_404_NOT_FOUND)

        if use_period_groups and periode is not None:
            for categorie in data['begroot']:
                list_periods = []
                for bucket_name in data['begroot'][categorie]:
                    start = bucket_name[:4]
                    end = bucket_name[5:]
                    period_entry = {
                        'start': start,
                        'end': end,
                        'begroot': data['begroot'][categorie][bucket_name]
                    }
                    list_periods.append(period_entry)
                data['begroot'][categorie] = list_periods

        return JsonResponse(data)
