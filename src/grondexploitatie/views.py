import re
import datetime
import logging
import json
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.reverse import reverse
from django.http import JsonResponse
from django.db import connection

from rest_framework.status import HTTP_400_BAD_REQUEST, HTTP_404_NOT_FOUND

log = logging.getLogger(__name__)


def get_start_jaar(request):
    now = datetime.datetime.now()
    current_year = now.year
    if 'start_jaar' in request.query_params:
        start_jaar = request.query_params['start_jaar']
        start_jaar = int(start_jaar)
        if not 1900 <= start_jaar <= current_year + 5:
            raise ValueError
    else:
        start_jaar = current_year
    return start_jaar


class ProjectList(APIView):
    def get(self, request):
        """
        Geef lijst van alle projecten waarvoor er baten zijn vanaf het 'start_jaar'
        Default is 'start_jaar' het huidige jaar
        """
        try:
            start_jaar = get_start_jaar(request)
        except ValueError:
            return Response(status=HTTP_400_BAD_REQUEST)

        sql = '''select g.plannr as project
        , g.plannaam as naam
        from grex_grenzen g
        join planex p on g.plannr = p.plannr
        where p.kosten_baten = 'Baten'
        and p.periode >= %s
        group by 1,2 order by 1,2
        '''
        results = []
        with connection.cursor() as cursor:
            cursor.execute(sql, [start_jaar])
            for row in cursor.fetchall():
                (plannr, plannaam) = row
                href = reverse('project_detail', kwargs=dict(plannr=plannr), request=request)
                results.append({
                    'plannr': plannr,
                    'plannaam': plannaam,
                    '_links': {
                        'self': {
                            'href': href
                        }
                    }
                })

        data = {
            "count": len(results),
            "results": results,
        }

        return JsonResponse(data)


def ceil_to_nice_number(number):
    """
    Round to a
    :param number:
    :return: ceiled number starting wit 1,2 or 5
    """
    str_number = str(number)
    left_digit = int(str_number[0:1])
    rest = str_number[1:]
    rest_len = len(rest)
    if rest.count('0') != len(rest):
        left_digit += 1
    if left_digit == 3 or left_digit == 4:
        left_digit = 5
    elif left_digit >= 6:
        left_digit = 1
        rest_len += 1
    return int(str(left_digit) + '0' * rest_len)


def name_period(start_year, end_year):
    if start_year == end_year:
        return str(start_year)
    else:
        return str(start_year) + ' - ' + str(end_year)


def get_start_end_year(period_name):
    if period_name.find('-') == -1:
        return int(period_name), int(period_name)
    else:
        return int(period_name[:4]), int(period_name[7:])


def get_kosten_baten_data(all_categories, start_jaar, last_year, period_bucket_size, data):
    all_buckets = [
        name_period(start_jaar, start_jaar)
    ]
    start = start_jaar + 1
    while start <= last_year:
        all_buckets.append(name_period(start, start + period_bucket_size - 1))
        start += period_bucket_size

    max_begroot_jaren = 0

    jaren = []
    for bucket_name in all_buckets:
        bucket_categories = {}
        for categorie in all_categories:
            bucket_categories[categorie] = {}
            begroot = None
            if categorie in data:
                if bucket_name in data[categorie]:
                    begroot = data[categorie][bucket_name]
                    if begroot > max_begroot_jaren:
                        max_begroot_jaren = begroot
            if begroot is not None:
                bucket_categories[categorie]['begroot'] = begroot
        start, end = get_start_end_year(bucket_name)
        jaren.append({'name': bucket_name, 'start': start, 'end': end, 'categories': bucket_categories})

    # Organize totals
    t_start = start_jaar
    t_end = start_jaar
    total_categories = {}
    for categorie in all_categories:
        total_categories[categorie] = {}
        begroot = None
        geboekt = None
        if categorie in data and 'totaal' in data[categorie]:
            begroot = data[categorie]['totaal']['begroot']
            geboekt = data[categorie]['totaal']['geboekt']
            start = int(data[categorie]['totaal']['start'])
            if start < t_start:
                t_start = start
            end = int(data[categorie]['totaal']['end'])
            if end > t_end:
                t_end = end
        if begroot is not None:
            total_categories[categorie]['begroot'] = begroot
        if geboekt is not None:
            total_categories[categorie]['geboekt'] = geboekt

    return {
        'jaren': jaren,
        'max_jaren_axis_begroot': ceil_to_nice_number(max_begroot_jaren),
        'totaal': {'categories': total_categories, 'start': t_start, 'end': t_end},
    }


class ProjectDetail(APIView):
    """
    Toon details voor project met kosten en baten per categorie vanaf 'start_jaar'
    Default is 'start_jaar' het huidige jaar
    """
    _all_categories = None
    _kosten_categories = None
    _baten_categories = None

    @staticmethod
    def get_all_categories():
        if ProjectDetail._all_categories is None:
            with connection.cursor() as cursor:
                cursor.execute("select distinct(rapportagepost) from mapping_rapportage where kosten_baten = 'Baten' order by 1")
                rows = cursor.fetchall()
                ProjectDetail._all_categories = [item for sublist in rows for item in sublist]
        return ProjectDetail._all_categories

    @staticmethod
    def get_kosten_baten_categories():
        if ProjectDetail._kosten_categories is None or ProjectDetail._baten_categories is None:
            with connection.cursor() as cursor:
                cursor.execute('''
                    select distinct(rapportagepost) as post, kosten_baten
                    from mapping_rapportage
                    where rapportagepost != ''
                    order by 1
                ''')
                rows = cursor.fetchall()

                ProjectDetail._kosten_categories = []
                ProjectDetail._baten_categories = []

                for row in rows:
                    (post, kosten_baten) = row
                    if kosten_baten == 'Kosten':
                        ProjectDetail._kosten_categories.append(post)
                    if kosten_baten == 'Baten':
                        ProjectDetail._baten_categories.append(post)

    @staticmethod
    def get_kosten_categories():
        ProjectDetail.get_kosten_baten_categories();
        return ProjectDetail._kosten_categories;

    @staticmethod
    def get_baten_categories():
        ProjectDetail.get_kosten_baten_categories();
        return ProjectDetail._baten_categories;


    @staticmethod  # noqa: C901
    def get(request, plannr):
        version = int(request.GET.get('version', '2'))
        if version == 3:
            return ProjectDetail.get_v3(request, plannr)
        else:
            return ProjectDetail.get_v2(request, plannr)


    @staticmethod
    def get_v2(request, plannr):

        if not re.match('^\d{5}$', plannr):
            # This should never occur, see url spec in urls.py
            return Response(status=HTTP_400_BAD_REQUEST)

        try:
            start_jaar = get_start_jaar(request)
        except ValueError:
            return Response(status=HTTP_400_BAD_REQUEST)

        sqlplan = '''select g.plannr as project
                , g.plannaam as naam
                , g.startdatum as startdatum
                , g.planstatus as status
                , ST_AsGeoJSON(g.wkb_geometry) as geometrie
        from grex_grenzen g
        where g.plannr = %s and g.planstatus in ('A', 'T')
        order by g.planstatus
        '''

        with connection.cursor() as cursor:
            cursor.execute(sqlplan, [plannr])
            row = cursor.fetchone()
            if row is None:
                return Response(status=HTTP_404_NOT_FOUND)

            (plannr, plannaam, startdatum, planstatus, geometrie) = row
            geometrie = json.loads(geometrie)

            data = {
                'plannr': plannr,
                'plannaam': plannaam,
                'startdatum': startdatum,
                'planstatus': planstatus,
                'geometrie': geometrie,
                '_display': plannaam,
                'startjaar': start_jaar,
            }

            sql = '''select p.plannr as project
    , p.begroting_naam as begroting
    , p.prijspeildatum as prijspeildatum
    , m.rapportagepost as categorie
    , p.periode as periode
    , p.fase as fase
    , sum(p.nw_begroot) as begroot
    , sum(p.nw_geboekt) as geboekt
    from planex p
    join mapping_rapportage m on m.cataloguspost = p.cataloguspost_nummer
    where p.plannr = %s
        and p.kosten_baten = 'Baten'
    group by p.plannr
        , p.begroting_naam
        , p.prijspeildatum
        , m.rapportagepost
        , p.periode
        , p.fase
        order by 1, 2
        '''

            period_bucket_size = 4
            last_year = start_jaar
            cursor.execute(sql, [plannr])
            for row in cursor.fetchall():
                (plannr, begroting, prijspeildatum, categorie, periode, fase, begroot, geboekt) = row
                begroot = round(begroot)
                geboekt = round(geboekt)
                periode = int(periode) if periode else None
                if 'begroting' not in data:
                    data['begroting'] = begroting
                if 'prijspeildatum' not in data:
                    data['prijspeildatum'] = prijspeildatum
                if 'fase' not in data:
                    data['fase'] = fase
                if not (begroting == data['begroting'] and
                        prijspeildatum == data['prijspeildatum'] and
                        fase == data['fase']):
                    log.error("Wrong values in row {}".format(row))

                if periode is None:
                    continue
                if last_year < periode:
                    last_year = periode

                if categorie is not None:
                    if 'begroot' not in data:
                        data['begroot'] = dict()
                    if categorie not in data['begroot']:
                        data['begroot'][categorie] = dict()

                    # Compute per period in begroot
                    # We will group in buckets of the current year and then in periods of four years
                    if periode >= start_jaar:
                        if periode == start_jaar:
                            bucket_name = name_period(periode, periode)
                        else:  # periode > start_jaar
                            bucket_name = int((periode - (start_jaar + 1)) / period_bucket_size)
                            start_bucket_jaar = (start_jaar + 1) + period_bucket_size * bucket_name
                            end_bucket_jaar = start_bucket_jaar + period_bucket_size - 1
                            bucket_name = name_period(start_bucket_jaar, end_bucket_jaar)
                        if bucket_name not in data['begroot'][categorie]:
                            data['begroot'][categorie][bucket_name] = 0
                        data['begroot'][categorie][bucket_name] += begroot

                    # Compute totaal
                    if 'totaal' not in data['begroot'][categorie]:
                        data['begroot'][categorie]['totaal'] = {
                            'begroot': 0,
                            'geboekt': 0,
                            'start': str(start_jaar),
                            'huidig': str(start_jaar),
                            'end': str(start_jaar)
                        }

                    data['begroot'][categorie]['totaal']['begroot'] += begroot
                    if periode < start_jaar:
                        data['begroot'][categorie]['totaal']['geboekt'] += geboekt
                    if periode > int(data['begroot'][categorie]['totaal']['end']):
                        data['begroot'][categorie]['totaal']['end'] = str(periode)
                    if periode < int(data['begroot'][categorie]['totaal']['start']):
                        data['begroot'][categorie]['totaal']['start'] = str(periode)

        if 'prijspeildatum' not in data:
            data['prijspeildatum'] = None
        if 'fase' not in data:
            data['fase'] = None
        if 'begroting' not in data:
            data['begroting'] = None
        if 'begroot' not in data:
            data['begroot'] = None
        else:
            all_categories = ProjectDetail.get_all_categories()
            all_buckets = [
                name_period(start_jaar, start_jaar)
            ]
            start = start_jaar + 1
            while start <= last_year:
                all_buckets.append(name_period(start, start + period_bucket_size - 1))
                start += period_bucket_size

            max_begroot_jaren = 0

            jaren = []
            for bucket_name in all_buckets:
                bucket_categories = {}
                for categorie in all_categories:
                    bucket_categories[categorie] = {}
                    begroot = None
                    if categorie in data['begroot']:
                        if bucket_name in data['begroot'][categorie]:
                            begroot = data['begroot'][categorie][bucket_name]
                            if begroot > max_begroot_jaren:
                                max_begroot_jaren = begroot
                    if begroot is not None:
                        bucket_categories[categorie]['begroot'] = begroot
                start, end = get_start_end_year(bucket_name)
                jaren.append({'name': bucket_name, 'start': start, 'end': end, 'categories': bucket_categories})

            # Organize totals
            t_start = start_jaar
            t_end = start_jaar
            total_categories = {}
            for categorie in all_categories:
                total_categories[categorie] = {}
                begroot = None
                geboekt = None
                if categorie in data['begroot'] and 'totaal' in data['begroot'][categorie]:
                    begroot = data['begroot'][categorie]['totaal']['begroot']
                    geboekt = data['begroot'][categorie]['totaal']['geboekt']
                    start = int(data['begroot'][categorie]['totaal']['start'])
                    if start < t_start:
                        t_start = start
                    end = int(data['begroot'][categorie]['totaal']['end'])
                    if end > t_end:
                        t_end = end
                if begroot is not None:
                    total_categories[categorie]['begroot'] = begroot
                if geboekt is not None:
                    total_categories[categorie]['geboekt'] = geboekt

            data['begroot'] = {
                'jaren': jaren,
                'max_jaren_axis_begroot': ceil_to_nice_number(max_begroot_jaren),
                'totaal': {'categories': total_categories, 'start': t_start, 'end': t_end},
            }

        return JsonResponse(data)


    @staticmethod
    def get_v3(request, plannr):

        if not re.match('^\d{5}$', plannr):
            # This should never occur, see url spec in urls.py
            return Response(status=HTTP_400_BAD_REQUEST)

        try:
            start_jaar = get_start_jaar(request)
        except ValueError:
            return Response(status=HTTP_400_BAD_REQUEST)

        sqlplan = '''
            select g.plannr as project
                , g.plannaam as naam
                , g.startdatum as startdatum
                , g.planstatus as status
                , ST_AsGeoJSON(g.wkb_geometry) as geometrie
            from grex_grenzen g
            where g.plannr = %s and g.planstatus in ('A', 'T')
            order by g.planstatus
        '''

        with connection.cursor() as cursor:
            cursor.execute(sqlplan, [plannr])
            row = cursor.fetchone()
            if row is None:
                return Response(status=HTTP_404_NOT_FOUND)

            (plannr, plannaam, startdatum, planstatus, geometrie) = row
            geometrie = json.loads(geometrie)

            data = {
                'plannr': plannr,
                'plannaam': plannaam,
                'startdatum': startdatum,
                'planstatus': planstatus,
                'geometrie': geometrie,
                '_display': plannaam,
                'startjaar': start_jaar,
            }

            sql = '''
                select p.plannr as project
                    , p.kosten_baten as kosten_baten
                    , p.begroting_naam as begroting
                    , p.prijspeildatum as prijspeildatum
                    , m.rapportagepost as categorie
                    , p.periode as periode
                    , p.fase as fase
                    , sum(p.nw_begroot) as begroot
                    , sum(p.nw_geboekt) as geboekt
                from planex p
                join mapping_rapportage m on m.cataloguspost = p.cataloguspost_nummer
                where p.plannr = %s
                group by p.plannr
                    , p.kosten_baten
                    , p.begroting_naam
                    , p.prijspeildatum
                    , m.rapportagepost
                    , p.periode
                    , p.fase
                order by 1, 2
            '''

            period_bucket_size = 4
            last_year = start_jaar
            cursor.execute(sql, [plannr])
            for row in cursor.fetchall():
                (plannr, kosten_baten, begroting, prijspeildatum, categorie, periode, fase, begroot, geboekt) = row
                begroot = round(begroot)
                geboekt = round(geboekt)
                periode = int(periode) if periode else None
                if 'begroting' not in data:
                    data['begroting'] = begroting
                if 'prijspeildatum' not in data:
                    data['prijspeildatum'] = prijspeildatum
                if 'fase' not in data:
                    data['fase'] = fase
                if not (begroting == data['begroting'] and
                        prijspeildatum == data['prijspeildatum'] and
                        fase == data['fase']):
                    log.error("Wrong values in row {}".format(row))

                if periode is None:
                    continue
                if last_year < periode:
                    last_year = periode

                if categorie is not None:
                    kosten_baten = 'kosten' if kosten_baten == 'Kosten' else 'baten'

                    if kosten_baten not in data:
                        data[kosten_baten] = dict()
                    if categorie not in data[kosten_baten]:
                        data[kosten_baten][categorie] = dict()

                    # Compute per period in begroot
                    # We will group in buckets of the current year and then in periods of four years
                    if periode >= start_jaar:
                        if periode == start_jaar:
                            bucket_name = name_period(periode, periode)
                        else:  # periode > start_jaar
                            bucket_name = int((periode - (start_jaar + 1)) / period_bucket_size)
                            start_bucket_jaar = (start_jaar + 1) + period_bucket_size * bucket_name
                            end_bucket_jaar = start_bucket_jaar + period_bucket_size - 1
                            bucket_name = name_period(start_bucket_jaar, end_bucket_jaar)
                        if bucket_name not in data[kosten_baten][categorie]:
                            data[kosten_baten][categorie][bucket_name] = 0
                        data[kosten_baten][categorie][bucket_name] += begroot

                    # Compute totaal
                    if 'totaal' not in data[kosten_baten][categorie]:
                        data[kosten_baten][categorie]['totaal'] = {
                            'begroot': 0,
                            'geboekt': 0,
                            'start': str(start_jaar),
                            'huidig': str(start_jaar),
                            'end': str(start_jaar)
                        }

                    data[kosten_baten][categorie]['totaal']['begroot'] += begroot
                    if periode < start_jaar:
                        data[kosten_baten][categorie]['totaal']['geboekt'] += geboekt
                    if periode > int(data[kosten_baten][categorie]['totaal']['end']):
                        data[kosten_baten][categorie]['totaal']['end'] = str(periode)
                    if periode < int(data[kosten_baten][categorie]['totaal']['start']):
                        data[kosten_baten][categorie]['totaal']['start'] = str(periode)

        if 'prijspeildatum' not in data:
            data['prijspeildatum'] = None
        if 'fase' not in data:
            data['fase'] = None
        if 'begroting' not in data:
            data['begroting'] = None
        if 'kosten' not in data:
            data['kosten'] = None
        else:
            all_categories = ProjectDetail.get_kosten_categories()
            data['kosten'] = get_kosten_baten_data(all_categories, start_jaar, last_year, period_bucket_size, data['kosten']);
        if 'baten' not in data:
            data['baten'] = None
        else:
            all_categories = ProjectDetail.get_baten_categories()
            data['baten'] = get_kosten_baten_data(all_categories, start_jaar, last_year, period_bucket_size, data['baten']);

        return JsonResponse(data)
